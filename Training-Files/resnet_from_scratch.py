# -*- coding: utf-8 -*-
"""resnet_from_scratch

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jjqHbbE2xjTxVyaeg31nDiTg6oI_Ukoh
"""

import torch
import matplotlib.pyplot as plt
import torch.nn as nn
import torch.optim as optim
import torchvision
from torchvision import datasets,transforms
import numpy as np
import time
import pandas as pd
import torch.nn.functional as F

class residual_block(nn.Module):
  def __init__(self,input,output,d=None,strides=1):
    super(residual_block,self).__init__()
    self.expansion=4
    self.conv1=nn.Conv2d(input,output,kernel_size=1,stride=1,padding=0,bias=False)
    self.norm2d1=nn.BatchNorm2d(output)
    self.conv2=nn.Conv2d(output,output,kernel_size=1,stride=strides,padding=0,bias=False)
    self.norm2d2=nn.BatchNorm2d(output)
    self.relu=nn.ReLU(inplace=True)
    k=(self.expansion)*output
    self.conv3=nn.Conv2d(output,k,kernel_size=1,stride=1,padding=0,bias=False)
    self.norm2d3=nn.BatchNorm2d(k)
    self.stride=strides
    self.d=d

  def forward(self,data):
    x=data.clone()
    y=self.conv1(data)
    y=self.norm2d1(y)
    y=self.relu(y)
    y=self.conv2(y)
    y=self.norm2d2(y)
    y=self.relu(y)
    y=self.conv3(y)
    y=self.norm2d3(y)

    if (self.d!= None):
      x=self.d(x)
    y+=x
    y=self.relu(y)
    return y



class Resnet(nn.Module):
  def __init__(self,residual_block,layers,channels,n=2):
    super(Resnet,self).__init__()
    self.input_channels=64
    self.conv1=nn.Conv2d(channels,self.input_channels,kernel_size=7,stride=2,padding=3,bias=False)
    self.norm1=nn.BatchNorm2d(self.input_channels)
    self.relu=nn.ReLU(inplace=True)
    self.pool=nn.MaxPool2d(kernel_size=3,stride=2,padding=1)

    self.layer1=self.init_layers(residual_block,layers[0],64,1)
    #print("bye")
    self.layer2=self.init_layers(residual_block,layers[1],128,2)
    self.layer3=self.init_layers(residual_block,layers[2],256,2)
    self.layer4=self.init_layers(residual_block,layers[3],512,2)
    #print("bye")
    self.avgpool=nn.AdaptiveAvgPool2d((1,1))
    self.fc=nn.Linear(512*4,n)

  def init_layers(self,block,layer,output,stride):
    d=None
    layers=[]
    k=output*4
    if(self.input_channels!=k or stride!=1):
      d=nn.Sequential(nn.Conv2d(self.input_channels,k,kernel_size=1,stride=stride,bias=False),nn.BatchNorm2d(k))
    if(stride!=1):
      d=nn.Sequential(nn.Conv2d(self.input_channels,k,kernel_size=1,stride=stride,bias=False),nn.BatchNorm2d(k))
    
    layers.append(block(self.input_channels,output,d,stride))
    self.input_channels=k
    for i in range(1,layer):
      layers.append(block(self.input_channels,output))
    return nn.Sequential(*layers)
  
  def forward(self,x):
    x=self.conv1(x)
    x=self.norm1(x)
    x=self.relu(x)
    x=self.pool(x)
    x=self.layer1(x)
    x=self.layer2(x)
    x=self.layer3(x)
    x=self.layer4(x)

    x=self.avgpool(x)
    x=x.reshape(x.shape[0],-1)
    x=self.fc(x)
    return x

def Resnet50(img=3,n=2):
  return Resnet(residual_block,[3,4,6,3],img,n)





